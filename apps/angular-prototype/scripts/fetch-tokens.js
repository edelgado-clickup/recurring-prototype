/**
 * Supernova Design Token Fetcher
 * 
 * This script connects to Supernova and fetches design tokens,
 * then exports them as SCSS variables for use in Angular components.
 */

require('dotenv').config();
const { Supernova } = require('@supernovaio/supernova-sdk');
const fs = require('fs');
const path = require('path');

// Configuration
const config = {
  apiToken: process.env.SUPERNOVA_API_TOKEN,
  workspaceId: process.env.SUPERNOVA_WORKSPACE_ID,
  designSystemId: process.env.SUPERNOVA_DESIGN_SYSTEM_ID,
};

// Validate configuration
function validateConfig() {
  const missing = [];
  if (!config.apiToken) missing.push('SUPERNOVA_API_TOKEN');
  if (!config.workspaceId) missing.push('SUPERNOVA_WORKSPACE_ID');
  if (!config.designSystemId) missing.push('SUPERNOVA_DESIGN_SYSTEM_ID');

  if (missing.length > 0) {
    console.error('‚ùå Missing required environment variables:');
    missing.forEach(key => console.error(`   - ${key}`));
    console.error('\nPlease update your .env file with the required values.');
    process.exit(1);
  }
}

// Convert token name to SCSS variable format
function tokenNameToScssVar(name) {
  let varName = name
    .replace(/\./g, '-')
    .replace(/\s+/g, '-')
    .replace(/[^a-zA-Z0-9-_]/g, '-') // Replace special characters with dash
    .replace(/--+/g, '-') // Replace multiple dashes with single dash
    .replace(/^-/, '') // Remove leading dash
    .replace(/-$/, '') // Remove trailing dash
    .toLowerCase();
  
  // If it starts with a number, prefix with 'token-'
  if (/^\d/.test(varName)) {
    varName = 'token-' + varName;
  }
  
  // If empty or invalid, use a safe default
  if (!varName || varName === '') {
    varName = 'token-unnamed';
  }
  
  return varName;
}

// Convert token name to TypeScript/JavaScript identifier
function tokenNameToJsIdentifier(name) {
  let identifier = name
    .replace(/[^a-zA-Z0-9_]/g, '_') // Replace special characters with underscore
    .replace(/__+/g, '_') // Replace multiple underscores with single underscore
    .replace(/^_/, '') // Remove leading underscore
    .replace(/_$/, ''); // Remove trailing underscore
  
  // If it starts with a number, prefix with '_'
  if (/^\d/.test(identifier)) {
    identifier = '_' + identifier;
  }
  
  // If empty or invalid, use a safe default
  if (!identifier || identifier === '') {
    identifier = '_token_unnamed';
  }
  
  return identifier;
}

// Extract clean token data without circular references
function extractTokenData(token) {
  return {
    id: token.id,
    name: token.name,
    description: token.description || '',
    tokenType: token.tokenType,
    value: token.value,
    origin: token.origin
  };
}

// Format token value for SCSS
function formatTokenValue(token) {
  const value = token.value;
  
  if (!value) return '""';
  
  if (typeof value === 'object') {
    // Handle color tokens
    if (value.hex) {
      const hex = String(value.hex);
      return hex.startsWith('#') ? hex : `#${hex}`;
    }
    if (value.color) {
      const color = String(value.color);
      return color.startsWith('#') ? color : `#${color}`;
    }
    if (value.r !== undefined) {
      return `rgba(${value.r}, ${value.g}, ${value.b}, ${value.a !== undefined ? value.a : 1})`;
    }
    
    // Handle dimension/size tokens
    if (value.measure !== undefined && value.unit !== undefined) {
      const unit = value.unit === 'Pixels' ? 'px' : value.unit === 'Percent' ? '%' : value.unit.toLowerCase();
      return `${value.measure}${unit}`;
    }
    
    // Handle typography tokens (just extract font family for now)
    if (value.font && value.font.family) {
      return `"${value.font.family}"`;
    }
    
    // Handle text/string tokens
    if (value.text) return `"${value.text}"`;
    
    // Handle reference tokens
    if (value.referencedToken) {
      return formatTokenValue({ value: value.referencedToken.value });
    }
    
    // Skip complex objects that can't be represented in SCSS
    return null;
  }
  
  // Handle string and number values
  if (typeof value === 'string') {
    return value;
  }
  
  return String(value);
}

// Generate SCSS variables file
function generateScssVariables(tokens) {
  let scss = `// Design Tokens from Supernova
// Auto-generated on ${new Date().toISOString()}
// Do not edit this file manually - run 'npm run fetch-tokens' to update

`;

  // Extract clean data and group tokens by type
  const tokensByType = {};
  const usedNames = new Map(); // Track used names to avoid duplicates
  
  tokens.forEach(token => {
    const cleanToken = extractTokenData(token);
    const type = cleanToken.tokenType || 'other';
    if (!tokensByType[type]) {
      tokensByType[type] = [];
    }
    tokensByType[type].push(cleanToken);
  });

  // Generate SCSS for each type
  Object.keys(tokensByType).sort().forEach(type => {
    scss += `\n// ${type.charAt(0).toUpperCase() + type.slice(1)} Tokens\n`;
    tokensByType[type].forEach(token => {
      let varName = tokenNameToScssVar(token.name);
      
      // Handle duplicate names
      if (usedNames.has(varName)) {
        const count = usedNames.get(varName) + 1;
        usedNames.set(varName, count);
        varName = `${varName}-${count}`;
      } else {
        usedNames.set(varName, 0);
      }
      
      const value = formatTokenValue(token);
      
      // Skip tokens with invalid or complex values
      if (!value || value === null || value === '[object Object]' || value === '#[object Object]') {
        scss += `// Skipped: $${varName} (complex/unsupported value type)\n`;
        return;
      }
      
      scss += `$${varName}: ${value};\n`;
      
      if (token.description) {
        scss += `// ${token.description}\n`;
      }
    });
  });

  return scss;
}

// Generate CSS custom properties file
function generateCssVariables(tokens) {
  let css = `/* Design Tokens from Supernova */
/* Auto-generated on ${new Date().toISOString()} */
/* Do not edit this file manually - run 'npm run fetch-tokens' to update */

:root {
`;

  const usedNames = new Map();
  
  tokens.forEach(token => {
    const cleanToken = extractTokenData(token);
    let varName = tokenNameToScssVar(cleanToken.name);
    
    // Handle duplicate names
    if (usedNames.has(varName)) {
      const count = usedNames.get(varName) + 1;
      usedNames.set(varName, count);
      varName = `${varName}-${count}`;
    } else {
      usedNames.set(varName, 0);
    }
    
    const value = formatTokenValue(cleanToken);
    
    // Skip tokens with invalid or complex values
    if (!value || value === null || value === '[object Object]' || value === '#[object Object]') {
      return;
    }
    
    css += `  --${varName}: ${value};\n`;
  });

  css += `}\n`;
  return css;
}

// Generate TypeScript constants file
function generateTypeScriptConstants(tokens) {
  let ts = `/**
 * Design Tokens from Supernova
 * Auto-generated on ${new Date().toISOString()}
 * Do not edit this file manually - run 'npm run fetch-tokens' to update
 */

export const DesignTokens = {
`;

  const usedNames = new Map();
  
  tokens.forEach(token => {
    const cleanToken = extractTokenData(token);
    let name = tokenNameToJsIdentifier(cleanToken.name);
    
    // Handle duplicate names
    if (usedNames.has(name)) {
      const count = usedNames.get(name) + 1;
      usedNames.set(name, count);
      name = `${name}_${count}`;
    } else {
      usedNames.set(name, 0);
    }
    
    const value = formatTokenValue(cleanToken);
    
    // Skip tokens with invalid or complex values
    if (!value || value === null || value === '[object Object]' || value === '#[object Object]') {
      return;
    }
    
    const escapedValue = value.replace(/\\/g, '\\\\').replace(/'/g, "\\'"); // Escape backslashes and single quotes
    ts += `  '${name}': '${escapedValue}',\n`;
  });

  ts += `} as const;\n\n`;
  ts += `export type DesignToken = keyof typeof DesignTokens;\n`;
  
  return ts;
}

// Main function
async function fetchTokens() {
  console.log('üöÄ Fetching design tokens from Supernova...\n');
  
  validateConfig();

  try {
    // Initialize Supernova SDK
    console.log('Initializing Supernova SDK...');
    console.log('Workspace ID:', config.workspaceId);
    console.log('Design System ID:', config.designSystemId);
    console.log('Token (first 10 chars):', config.apiToken.substring(0, 10) + '...');
    
    const supernova = new Supernova(config.apiToken);
    
    console.log('‚úì Connected to Supernova');
    
    // Fetch workspace
    console.log('Fetching workspace...');
    const workspace = await supernova.workspace(config.workspaceId);
    console.log(`‚úì Loaded workspace: ${workspace.name || config.workspaceId}`);
    
    // Fetch design system
    console.log('Fetching design system...');
    const designSystem = await supernova.designSystem(config.designSystemId);
    console.log(`‚úì Loaded design system: ${designSystem.name || config.designSystemId}`);
    
    // Fetch the active version
    console.log('Fetching active version...');
    const version = await designSystem.activeVersion();
    console.log(`‚úì Loaded version: ${version.name || version.id}`);
    
    // Fetch tokens
    console.log('Fetching tokens...');
    const tokens = await version.tokens();
    console.log(`‚úì Fetched ${tokens.length} design tokens\n`);

    if (tokens.length === 0) {
      console.warn('‚ö†Ô∏è  No tokens found in the design system');
      return;
    }

    // Create output directory
    const outputDir = path.join(__dirname, '../src/styles/tokens');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Generate and save SCSS variables
    const scssContent = generateScssVariables(tokens);
    const scssPath = path.join(outputDir, '_tokens.scss');
    fs.writeFileSync(scssPath, scssContent);
    console.log(`‚úì Generated SCSS variables: ${scssPath}`);

    // Generate and save CSS custom properties
    const cssContent = generateCssVariables(tokens);
    const cssPath = path.join(outputDir, 'tokens.css');
    fs.writeFileSync(cssPath, cssContent);
    console.log(`‚úì Generated CSS custom properties: ${cssPath}`);

    // Generate and save TypeScript constants
    const tsContent = generateTypeScriptConstants(tokens);
    const tsPath = path.join(outputDir, 'tokens.ts');
    fs.writeFileSync(tsPath, tsContent);
    console.log(`‚úì Generated TypeScript constants: ${tsPath}`);

    console.log('\n‚úÖ Design tokens successfully fetched and exported!');
    console.log('\nUsage:');
    console.log('  SCSS: @import "styles/tokens/tokens";');
    console.log('  CSS:  @import "styles/tokens/tokens.css";');
    console.log('  TS:   import { DesignTokens } from "./styles/tokens/tokens";');

  } catch (error) {
    console.error('\n‚ùå Error fetching tokens:', error.message);
    if (error.response) {
      console.error('Response:', error.response.data);
    }
    process.exit(1);
  }
}

// Run the script
fetchTokens();

